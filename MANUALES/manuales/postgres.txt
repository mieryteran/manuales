POSTGRES

<pre>

<table border="1" border="1" width="100%" align="center">
<tr>
	<td>ACCIONES</td><td>COMANDOS</td>
</tr>
<tr>
	<td></td>
	<td></td>
</tr>
</tr>
</table>



create table

create table NOMBRETABLA(
  CAMPO TIPO,
  ...
  primary key (NOMBRECAMPO)
 );

 primary key(NOMBRECAMPO1,NOMBRECAMPO2) 

create table libros(
  id bigserial,
  titulo varchar(30) not null,
  autor varchar(20) not null,
  editorial varchar(15) null,
  estatus smallint default 1,
  precio float 
 );

-------------------------------------------------------------------------------------------------

eliminar tabla: drop table usuarios;
vaciar tabla : DELETE table libros; --mas lento
vaciar tabla : truncate table libros; --mas rapido

-------------------------------------------------------------------------------------------------

tipos de datos basicos :

varchar -- 'nombre' longitud variable
char    -- 'nombre' longitud fija
integer -- 5 enteros
float   -- 10.23 decimales or double precision
text    -- 1gb almacenamiento

int (integer o int4): su rango es de -2000000000 a 2000000000 aprox.
smallint (int2): Puede contener hasta 5 digitos. Su rango va desde ?32000 hasta 32000 aprox.
bigint (int8): De ?9000000000000000000 hasta 9000000000000000000 aprox.
Los campos de tipo serial : se almacenan en un campo de tipo int
y los bigserial : se almacenan en un campo de tipo bigint.
decimal o numeric (t,d): Pueden tener hasta 1000 digitos, guarda un valor exacto. El primer argumento indica el total de dígitos y el segundo, la cantidad de decimales.

date: almacena una fecha en el rango de 4713 antes de crísto hasta 32767 después de cristo.
time: Almacena la hora del día.
timestamp: Almacena la fecha y la hora del día.
PostgreSQL permite configurar el formato de ingreso de la fecha seteando la variable de entorno llamada DATESTYLE:
SET DATESTYLE TO 'European'; = dd/mm/yyyy

-------------------------------------------------------------------------------------------------

clausulas:

where CONDITION

having CONDITION permite seleccionar (o rechazar) un grupo de registros (group by)

 select editorial, count(*) from libros
  group by editorial
  having count(*)>2;

   select editorial, avg(precio) from libros
  group by editorial
  having count(*) > 2; 

default VALORES POR DEFECTO 
También se puede utilizar "default" para dar el valor por defecto a los campos en sentencias "insert", por ejemplo:
    insert into libros (titulo,autor,precio,cantidad)
    values ('El gato con botas',default,default,100);
	Si todos los campos de una tabla tienen valores predeterminados (ya sea por ser "identity", permitir valores nulos o tener un valor por defecto), se puede ingresar un registro de la siguiente manera:
	insert into libros default values;

group by

group by 1,2..

order by 
  	order by titulo asc, editorial desc;

CLAUSULA distinct

select distinct autor from libros;

select count(distinct autor)
  from libros;

CLAUSULA LIMIT Y OFFSET

offset indica el número del primer registro a retornar

 select * from libros limit 4 offset 0;

Muestra los primeros 4 registros, 0,1,2 y 3.

Si tipeamos:

 select * from libros limit 4 offset 5;

recuperamos 4 registros, desde el 5 al 8.




 -------------------------------------------------------------------------------------------------

tipos de operadores: 
1) relacionales o de comparación 
2) lógicos
3) aritméticos multiplicación (*), división (/) y módulo (%) (el resto de dividir números enteros), suma (+) y resta (-)
 
 select titulo, precio,cantidad,
  precio*cantidad
  from libros;

   select titulo,precio,
  precio-(precio*0.1)
  from libros;

  update libros set precio=precio-(precio*0.1);

4) concatenación.  || 

select titulo||'-'||autor||'-'||editorial
  from libros;
-------------------------------------------------------------------------------------------------
operadores  relacionales o de comparacion

=	igual
<>	distinto
>	mayor
<	menor
>=	mayor o igual
<=	menor o igual
is null
is not null
between
in
any, some
all
exists
no exists
like comience 'M%' reemplazar caracter "%Carrol_" 

 select * from libros
  where autor='Borges' or autor='Paenza';

Podemos usar "in" y simplificar la consulta:

 select * from libros
  where autor in('Borges','Paenza');

  uso de parentesis

  select * from libros
  where (autor='Borges') or
  (editorial='Paidos' and precio<20);


-------------------------------------------------------------------------------------------------

operadores logicos

- and, significa "y",
- or, significa "y/o",
- not, significa "no", invierte el resultado
- (), paréntesis

 select * from libros
  where (autor='Borges' or editorial='Paidos') and
  (precio<20);

orden prioridad not -> and -> or
-------------------------------------------------------------------------------------------------

alias : as

-------------------------------------------------------------------------------------------------

funciones de agrupamiento (agregado)
select:

count(*)
sum(precio)
min(CAMPO)
max(CAMPO)
avg() promedio

-------------------------------------------------------------------------------------------------
RESTRICCIONES
-------------------------------------------------------------------------------------------------

  CHECK

    La restricción "check" especifica los valores que acepta un campo, evitando que se ingresen valores inapropiados.

    La sintaxis básica es la siguiente:

    alter table NOMBRETABLA
    add constraint NOMBRECONSTRAINT
    check CONDICION;

    alter table libros
    add constraint CK_libros_preciominmay
    check (preciomay<=preciomin);

    Este tipo de restricción verifica los datos cada vez que se ejecuta una sentencia "insert" o "update", es decir, actúa en inserciones y actualizaciones.

    ALTER TABLE table_name
    ALTER COLUMN column_name datatype; 

    ALTER TABLE empledos ALTER COLUMN nombre_columna SET NOT NULL

    ALTER TABLE table_name
    ADD column_name datatype default 1; 

    ALTER TABLE table_name
    DROP COLUMN column_name; 

    ALTER TABLE empleados RENAME COLUMN nombre_actual TO nombre_nuevo

PRIMARY KEY
  
   alter table libros
   add constraint PK_libros_codigo
   primary key(codigo);

UNIQUE

  alter table alumnos
  add constraint UQ_alumnos_documento
  unique (documento);

FOREIGN KEY

  alter table afiliados
  add constraint FK_afiliados_afiliadotitular
  foreign key (afiliadotitular)
  references afiliados (numero);

  alter table NOMBRETABLA1
  add constraint NOMBRERESTRICCION
  foreign key (CAMPOCLAVEFORANEA)
  references NOMBRETABLA2 (CAMPOCLAVEPRIMARIA);

  CLAUSULAS

  -no action
  -cascade
  -set null
  -set default

  alter table TABLA1
  add constraint NOMBRERESTRICCION
  foreign key (CAMPOCLAVEFORANEA)
  references TABLA2(CAMPOCLAVEPRIMARIA)
  on delete OPCION
  on update OPCION;

  alter table libros
  add constraint FK_libros_codigoeditorial
  foreign key (codigoeditorial)
  references editoriales(codigo)
  on update cascade
  on delete cascade;

 La tabla referenciada debe tener definida una restricción "primary key" o "unique"; si no la tiene, aparece un mensaje de error.

ELIMINAR RESTRICCIONES

  alter table NOMBRETABLA
  drop constraint NOMBRERESTRICCION;



-------------------------------------------------------------------------------------------------
UNION (ALL para mostrar dulplicados)

El operador "union" combina el resultado de dos o más instrucciones "select" en un único resultado.
Se deben especificar los nombres de los campos en la primera instrucción "select".
-------------------------------------------------------------------------------------------------

   select nombre, domicilio from alumnos
  union
   select nombre, domicilio from profesores;

-------------------------------------------------------------------------------------------------
SUBCONSULTAS
-------------------------------------------------------------------------------------------------
SUBCONSULTAS COMO EXPRESIÓN
  
  select CAMPOS
  from TABLA
  where CAMPO OPERADOR (SUBCONSULTA);

  select CAMPO OPERADOR (SUBCONSULTA)
  from TABLA;

  select titulo,precio,
  precio-(select max(precio) from libros) as diferencia
  from libros
  where titulo='Uno';

  update TABLA set CAMPO=NUEVOVALOR
  where CAMPO= (SUBCONSULTA);

  delete from TABLA
  where CAMPO=(SUBCONSULTA);

SUBCONSULTAS CON IN
  
  select nombre
  from editoriales
  where codigo in
   (select codigoeditorial
     from libros
     where autor='Richard Bach');

SUBCONSULTAS ANY - SOME - ALL

--puede trabajar con arreglos
--trabajo can varios operadores

 ...VALORESCALAR OPERADORDECOMPARACION
  ANY (SUBCONSULTA);

  Compara un valor escalar con los valores de un campo y devuelven "true" si la comparación con cada valor de la lista de la subconsulta es verdadera, sino "false".

  select titulo
  from libros
  where autor='Borges' and
  codigoeditorial = any
   (select e.codigo
    from editoriales as e
    join libros as l
    on codigoeditorial=e.codigo
    where l.autor='Richard Bach');

    select titulo,precio
  from libros
  where autor='Borges' and
  precio > any
   (select precio
    from libros
    where autor='Bach');

  ALL

  "all" también compara un valor escalar con una serie de valores. Chequea si TODOS los valores de la lista de la consulta externa se encuentran en la lista de valores devuelta por la consulta interna.
  Sintaxis:

  VALORESCALAR OPERADORDECOMPARACION all (SUBCONSULTA);

  select titulo
  from libros
  where autor='Borges' and
  codigoeditorial = all
   (select e.codigo
    from editoriales as e
    join libros as l
    on codigoeditorial=e.codigo
    where l.autor='Richard Bach');


  Emplear "= any" es lo mismo que emplear "in".

  Emplear "<> all" es lo mismo que emplear "not in".

SUBCONSULTAS CORRELACIONADAS

  select f.*,
  (select count(d.numeroitem)
    from Detalles as d
    where f.numero=d.numerofactura) as cantidad,
  (select sum(d.preciounitario*cantidad)
    from Detalles as d
    where f.numero=d.numerofactura) as total
  from facturas as f;

  A este tipo de subconsulta se la denomina consulta correlacionada. La consulta interna se evalúa tantas veces como registros tiene la consulta externa, se realiza la subconsulta para cada registro de la consulta externa. El campo de la tabla dentro de la subconsulta (f.numero) se compara con el campo de la tabla externa.

SUBCONSULTAS (EXISTS Y NO EXISTS)

Cuando se coloca en una subconsulta el operador "exists", PostgreSQL analiza si hay datos que coinciden con la subconsulta, no se devuelve ningún registro, es como un test de existencia; PostgreSQL termina la recuperación de registros cuando por lo menos un registro cumple la condición "where" de la subconsulta.
  
   where exists (SUBCONSULTA);

   select cliente,numero
  from facturas as f
  where exists
   (select *from Detalles as d
     where f.numero=d.numerofactura
     and d.articulo='lapiz');

     select cliente,numero
  from facturas as f
  where not exists
   (select *from Detalles as d
     where f.numero=d.numerofactura
     and d.articulo='lapiz');

SUBCONSULTA SIMIL AUTOCOMBINACIÓN
  entre mismas tablas

  select distinct l1.titulo
  from libros as l1
  where l1.titulo in
  (select l2.titulo
    from libros as l2 
    where l1.editorial <> l2.editorial);

    select titulo
  from libros
  where titulo<>'El aleph' and
  precio =
   (select precio
     from libros
     where titulo='El aleph');

 SUBCONSULTA EN LUGAR DE UNA TABLA

  select ALIASdeTABLADERIVADA.CAMPO
  from (TABLADERIVADA) as ALIAS;

  Podemos probar la consulta que retorna la tabla derivada y luego agregar el "select" externo:

select f.*,
 (select sum(d.precio*cantidad)
  from Detalles as d
  where f.numero=d.numerofactura) as total
  from facturas as f;

La consulta anterior contiene una subconsulta correlacionada; retorna todos los datos de "facturas" y el monto total por factura de "detalles". Esta consulta retorna varios registros y varios campos y será la tabla derivada que emplearemos en la siguiente consulta:

 select td.numero,c.nombre,td.total
  from clientes as c
  join (select f.*,
   (select sum(d.precio*cantidad)
    from Detalles as d
    where f.numero=d.numerofactura) as total
  from facturas as f) as td
  on td.codigocliente=c.codigo;

SUBCONSULTA (UPDATE - DELETE)

  update TABLA set CAMPO=NUEVOVALOR
  where CAMPO= (SUBCONSULTA);

  update libros set precio=precio+(precio*0.1)
  where codigoeditorial=
   (select codigo
     from editoriales
     where nombre='Emece');

  delete from TABLA
  where CAMPO in (SUBCONSULTA);

  delete from libros
  where codigoeditorial in
   (select e.codigo
    from editoriales as e
    join libros
    on codigoeditorial=e.codigo
    where autor='Juan Perez');

SUBCONSULTA (INSERT)

  insert into TABLAENQUESEINGRESA (CAMPOSTABLA1)
  select (CAMPOSTABLACONSULTADA)
  from TABLACONSULTADA;

  insert into aprobados (documento,nota)
  select (documento,nota)
   from alumnos;

-------------------------------------------------------------------------------------------------
VISTAS
-------------------------------------------------------------------------------------------------

La sintaxis básica parcial para crear una vista es la siguiente:

 create view NOMBREVISTA as
  SENTENCIAS SELECT
   from TABLA;

El contenido de una vista se muestra con un "select":

 select *from NOMBREVISTA;

 ejemplo:

 create view vista_empleados as
  select (apellido||' '||e.nombre) as nombre,sexo,
   s.nombre as seccion, cantidadhijos
   from empleados as e
   join secciones as s
   on codigo=seccion

   select *from vista_empleados;

Podemos realizar consultas a una vista como si se tratara de una tabla:

 select seccion,count(*) as cantidad
  from vista_empleados;

  Otra sintaxis es la siguiente:

 create view NOMBREVISTA (NOMBRESDEENCABEZADOS)
  as
  SENTENCIASSELECT
   from TABLA;

   create view vista_empleados_ingreso (fecha,cantidad)
  as
  select extract(year from fechaingreso),count(*)
   from empleados
   group by extract(year from fechaingreso);

    Para quitar una vista se emplea "drop view":

 drop view NOMBREVISTA;

-------------------------------------------------------------------------------------------------
SECUENCIAS (CREATE SEQUENCE- ALTER SEQUENCE - NEXTVAL - DROP SEQUENCE)
-------------------------------------------------------------------------------------------------

create sequence NOMBRESECUENCIA
  start with VALORENTERO
  increment by VALORENTERO
  maxvalue VALORENTERO
  minvalue VALORENTERO
  cycle;

  create sequence sec_codigolibros
  start with 1
  increment by 1
  maxvalue 99999
  minvalue 1;

  Dijimos que las secuencias son tablas; por lo tanto se accede a ellas mediante consultas, empleando "select".

select * from sec_numerosocios;

ejemplo 

Creamos una secuencia para el código de la tabla "libros", especificando el valor máximo, el incremento y que no sea circular:

 create sequence sec_codigolibros
  minvalue 1000
  maxvalue 999999
  increment by 1;

Creamos la tabla libros y asociamos a la columna codigo la secuenca sec_codigolibros:

 create table libros(
  codigo nextval('sec_codigolibros'),
  titulo varchar(30),
  autor varchar(30),
  editorial varchar(15),
  primary key (codigo)
 );

Para eliminar una secuencia empleamos "drop sequence". Sintaxis:

 drop sequence NOMBRESECUENCIA;

drop sequence NOMBRESECUENCIA cascade;

Podemos modificar una secuencia con la siguiente sintaxis:

 alter sequence NOMBRESECUENCIA
  start with VALORENTERO
  increment by VALORENTERO
  maxvalue VALORENTERO
  minvalue VALORENTERO
  cycle;

-------------------------------------------------------------------------------------------------
INDICES (indexación)

La indexación es una técnica que optimiza el acceso a los datos, mejora el rendimiento acelerando las consultas y otras operaciones. Es útil cuando la tabla contiene miles de registros.
-------------------------------------------------------------------------------------------------

Hay distintos tipos de índices, a saber:

1) "primary key": es el que definimos como clave primaria. Los valores indexados deben ser únicos y además no pueden ser nulos. PostgreSQL le da el nombre "PRIMARY". Una tabla solamente puede tener una clave primaria.

2) "index": crea un indice común, los valores no necesariamente son únicos y aceptan valores "null". Podemos darle un nombre, si no se lo damos, se coloca uno por defecto. "key" es sinónimo de "index". Puede haber varios por tabla.

3) "unique": crea un indice para los cuales los valores deben ser únicos y diferentes, aparece un mensaje de error si intentamos agregar un registro con un valor ya existente. Permite valores nulos y pueden definirse varios por tabla. Podemos darle un nombre, si no se lo damos, se coloca uno por defecto.

INDEX

  Creamos un índice:

  create index I_libros_editorial on libros(editorial,....);

UNIQUE

  create unique index I_libros_tituloeditorial on libros(titulo,editorial);

PARA ELIMINAR UN ÍNDICE USAMOS "DROP INDEX". EJEMPLO:

 drop index I_libros_editorial;
 drop index I_libros_tituloeditorial;




-------------------------------------------------------------------------------------------------
JOIN (combinar)

Hay tres tipos de combinaciones:

    combinaciones internas (inner join o join),
    combinaciones externas. (left join y right join)
    combinaciones cruzadas.

-------------------------------------------------------------------------------------------------

 Combinación interna (inner join)

  select l.codigo,titulo,autor,nombre
  from libros as l
  join editoriales as e
  on l.codigoeditorial=e.codigo;

Combinación externa izquierda (left join)

  select CAMPOS
  from TABLAIZQUIERDA
  right join TABLADERECHA
  on CONDICION;

Combinación externa derecha (right join)

  select CAMPOS
  from TABLAIZQUIERDA
  right join TABLADERECHA
  on CONDICION;

Combinación externa completa (full join)

  select titulo,nombre
  from editoriales as e
  full join libros as l
  on codigoeditorial = e.codigo;

Combinaciones cruzadas (cross join)

  select CAMPOS
  from TABLA1
  cross join TABLA2;

  select c.nombre as platoprincipal, p.nombre as postre
  from comidas as c
  cross join postres as p;

combinaciones

  select titulo,a.nombre,e.nombre
  from autores as a
  right join libros as l
  on codigoautor=a.codigo
  left join editoriales as e  on codigoeditorial=e.codigo;

-------------------------------------------------------------------------------------------------

funciones para el manejo de cadenas

select:

char_length(string): Retorna la longitud del texto. Ejemplo:
select char_length('Hola');
retorna un 4.

upper(string): Retorna el texto convertido a mayúsculas. Ejemplo:
select upper('Hola');
retorna 'HOLA'.

lower(string): Retorna el texto convertido a minúsculas. Ejemplo:
select lower('Hola');
retorna 'hola'.

position(string in string): Retorna la posición de un string dentro de otro. Si no está contenido retorna un 0. Ejemplo:
select position('Mundo' in 'Hola Mundo');
retorna 6.

select position('MUNDO' in 'Hola Mundo');
retorna 0 (ya que no coinciden mayúsculas y minúsculas)

substring(): Retorna un substring, le indicamos la posición inicial y la cantidad de caracteres a extraer desde dicha posición. Ejemplo:
select substring('Hola Mundo' from 1 for 2);
retorna 'Ho'.

trim(): Elimina caracteres del principio o o final de un string. Por defecto elimina los espacios en blanco si no indicamos el caracter o string. Ejemplo:
select char_length(trim('  Hola Mundo  '));
retorna un 10

select trim(trailing '-' from '--Hola Mundo----');
retorna '--Hola Mundo'. Esto es debido a indicamos que elimine los guiones del final del stirng.

select trim(trailing '-' from '--Hola Mundo----');
retorna '--Hola Mundo'. Esto es debido a indicamos que elimine los guiones del final del stirng.

ltrim(string,string): Elimina los caracteres de la izquierda según el dato del segundo parámetro de la función. Ejemplo:
select char_length(ltrim('  Hola'));
retorna un 4.

select ltrim('---Hola','-');
retorna 'Hola'.

rtrim(string,string): Elimina los caracteres de la derecha según el dato del segundo parámetro de la función. Ejemplo:
select char_length(rtrim('Hola  '));
retorna un 4.

select rtrim('Hola----','-');
retorna un 'Hola'.

substr(text,int[,int]): Retorna una subcadena a partir de la posición que le indicamos en el segundo parámetro hasta la posición indicada en el tercer parámetro. Ejemplo:
select substr('Hola Mundo',2,4);
retorna 'ola'.

select substr('Hola Mundo',2);
retorna 'ola Mundo' (si no indicamos el tercer parámetro retorna todo el string hasta el final)

lpad(text,int,text): Rellena de caracteres por la izquierda. El tamaño total de campo es indicado por el segundo parámetro y el texto a insertar se indica en el tercero. Ejemplo:
select lpad('Hola Mundo',20,'-');
retorna '----------Hola Mundo'.

rpad(text,int,text): Rellena de caracteres por la derecha. El tamaño total de campo es indicado por el segundo parámetro y el texto a insertar se indica en el tercero. Ejemplo:
select rpad('Hola Mundo',20,'-');
retorna 'Hola Mundo----------'.

select rpad('Hola Mundo',20,'-*');
retorna 'Hola Mundo-*-*-*-*-*'.

-------------------------------------------------------------------------------------------------

funciones matematicas

-------------------------------------------------------------------------------------------------

abs(x): retorna el valor absoluto del argumento "x". Ejemplo:

 select abs(-20);

retorna 20.

cbrt(x): retorna la raíz cúbica del argumento "x". Ejemplo:

 select cbrt(27);

retorna 3.

ceiling(x): redondea hacia arriba el argumento "x". Ejemplo:

 select ceiling(12.34);

retorna 13.

floor(x): redondea hacia abajo el argumento "x". Ejemplo:

 select floor(12.34);

retorna 12.

power(x,y): retorna el valor de "x" elevado a la "y" potencia. Ejemplo:

 select power(2,3);

retorna 8.

round(numero): retorna un número redondeado al valor más próximo. Ejemplo:

 select round(10.4);

retorna "10".

sign(x): si el argumento es un valor positivo devuelve 1;-1 si es negativo y si es 0, 0. Ejemplo:

 select sign(-23.4);

retorna "-1".

sqrt(x): devuelve la raíz cuadrada del valor enviado como argumento. Ejemplo:

 select sqrt(9);

retorna "3".

mod(x,y): devuelve el resto de dividir x con respecto a y. Ejemplo:

 select mod(11,2);

retorna "1".

pi(): devuelve el valor de pi. Ejemplo:

 select pi();

retorna "3.14159265358979".

random(): devuelve un valor aleatorio entre 0 y 1 (sin incluirlos). Ejemplo:

 select random();

retorna por ejemplo "0.895562474101578".

trunc(x): Retorna la parte entera del parámetro. Ejemplo:

 select trunc(34.7);

retorna "34".

trunc(x,decimales): Retorna la parte entera del parámetro y la parte decimal truncando hasta el valor indicado en el segundo parámetro. Ejemplo:

 select trunc(34.7777,2);

retorna "34.77".

sin(x): Retorna el valor del seno en radianes. Ejemplo:

 select sin(0);

retorna "0".

cos(x): Retorna el valor del coseno en radianes. Ejemplo:

 select cos(0);

retorna "1".

tan(x): Retorna el valor de la tangente en radianes. Ejemplo:

 select tan(0);

retorna "0".

-------------------------------------------------------------------------------------------------

funciones de fecha y hora

-------------------------------------------------------------------------------------------------

- current_date: retorna la fecha actual. Ejemplo:

 select current_date;

Retorna por ejemplo '2009-05-20'

- current_time: retorna la hora actual con la zona horaria. Ejemplo:

 select current_time;

Retorna por ejemplo '18:33:06.074493+00'

- current_timestamp: retorna la fecha y la hora actual con la zona horaria. Ejemplo:

 select current_timestamp;

Retorna por ejemplo '2009-05-20 18:34:16.63131+00'

- extract(valor from timestamp): retorna una parte de la fecha u hora según le indiquemos antes del from, luego del from debemos indicar un campo o valor de tipo timestamp (o en su defecto anteceder la palabra clave timestamp para convertirlo). Ejemplo:

  select extract(year from  timestamp'2009-12-31 12:25:50');

Retorna el año '2009'

  select extract(month from  timestamp'2009-12-31 12:25:50');

Retorna el mes '12'

  select extract(day from  timestamp'2009-12-31 12:25:50');

Retorna el día '31'

  select extract(hour from  timestamp'2009-12-31 12:25:50');

Retorna la hora '12'

  select extract(minute from  timestamp'2009-12-31 12:25:50');

Retorna el minuto '25'

  select extract(second from  timestamp'2009-12-31 12:25:50');

Retorna el segundo '50'

  select extract(century from  timestamp'2009-12-31 12:25:50');

Retorna el siglo '21'

  select extract(dow from  timestamp'2009-12-31 12:25:50');

Retorna el día de a semana '4'

  select extract(doy from  timestamp'2009-12-31 12:25:50');

Retorna el día del año '365'

  select extract(week from  timestamp'2009-12-31 12:25:50');

Retorna el número de semana dentro del año '53'

  select extract(quarter from  timestamp'2009-12-31 12:25:50');

Retorna en que cuarto del año se ubica la fecha '4'

Para ver la estructura de una tabla consultaremos una tabla propia del PostgreSQL

SELECT table_name,column_name,udt_name,character_maximum_length 
  FROM information_schema.columns WHERE table_name = 'usuarios';

  drop table usuarios;

--------------------------------------------------------------------------------------

select table_name,column_name, udt_name, character_maximum_length,column_default from information_schema.columns where table_name = 'pruebas'

select *
  from information_schema.table_constraints 
  where table_name = 'pruebas';











  -------------------------------------------------------------------------------------------------
FUNCIONES
-------------------------------------------------------------------------------------------------

create or replace function [nombre de la función]([parámetros]) returns [tipo de dato que retorna]
as
 [definición de la función]
language [lenguaje utilizado]

La [definición de la función] depende del lenguaje utilizado para codificarla, pudiendo ser:

SQL
PL/PGSQL
PL/TCL
PL/Perl
C


SINTAXIS PARA IMPLEMENTAR UNA FUNCIÓN SQL: (RETORNAR DATOS SIMPLES)

  create or replace function [nombre de la función]([parámetros]) returns [tipo de dato que retorna]
  as
   [comandos sql]
  language sql


  create or replace function sumar(integer,integer) returns integer 
  AS 
    'select $1+$2;'
  language sql;

  Para llamar luego a esta función lo hacemos por ejemplo en un select:

  select sumar(3,4);

   create or replace function retornarclave(varchar) returns varchar
   as
     'select clave from usuarios where nombre=$1;'
   language sql;


FUNCIÓN SQL QUE NO RETORNA DATO (VOID)

   create or replace function [nombre de la función]([parámetros]) returns void
   as
   [comandos sql]
   language sql

   create or replace function cargarusuarios() returns void
   as
   $$
   insert into usuarios (nombre, clave) values ('Marcelo','Boca');
   insert into usuarios (nombre, clave) values ('JuanPerez','Juancito');
   insert into usuarios (nombre, clave) values ('Susana','River');
   insert into usuarios (nombre, clave) values ('Luis','River');
   $$
   language sql;

   create or replace function cargarusuarios() returns void
    as
    '
     insert into usuarios (nombre, clave) values (''Marcelo'',''Boca'');
     insert into usuarios (nombre, clave) values (''JuanPerez'',''Juancito'');
     insert into usuarios (nombre, clave) values (''Susana'',''River'');
     insert into usuarios (nombre, clave) values (''Luis'',''River'');
    '
    language sql;

    select cargarusuarios();

FUNCIÓN SQL QUE RETORNA UN DATO COMPUESTO.


  create or replace function retornarlibro(int) returns libros 
 as
 'select * from libros where codigo=$1 ;'
 language sql;

 select retornarlibro(4);


-------------------------------------------------------------------------------------------------
 PL / PGSQL
-------------------------------------------------------------------------------------------------
ESTRUCTURA

  CREATE FUNCTION somefunc(integer, text) RETURNS integer
  AS 'function body text'
  LANGUAGE plpgsql;

ESTRUCTURA EN BLOQUES

  [ <<label>> ]
  [ DECLARE
      declarations ]
  BEGIN
      statements
  END [ label ];

  CREATE FUNCTION somefunc() RETURNS integer AS $$
  << outerblock >>
  DECLARE
      quantity integer := 30;
  BEGIN
      RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
      quantity := 50;
      --
      -- Create a subblock
      --
      DECLARE
          quantity integer := 80;
      BEGIN
          RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
          RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
      END;

      RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

      RETURN quantity;
  END;
  $$ LANGUAGE plpgsql;

EJEMPLO DE DECLARACION DE VARIABLES:

  user_id integer;
  quantity numeric(5);
  url varchar;
  myrow tablename%ROWTYPE;
  myfield tablename.columnname%TYPE;
  arow RECORD;

LA SINTAXIS GENERAL DE UNA DECLARACIÓN DE VARIABLE ES:

  name [ CONSTANT ] type [ COLLATE collation_name ] [ NOT NULL ] [ { DEFAULT | := | = } expression ];

  La DEFAULT cláusula, si se da, especifica el valor inicial asignado a la variable cuando se ingresa el bloque. Si DEFAULT no se da la cláusula, la variable se inicializa al valor nulo de SQL .

  La CONSTANT opción impide que se asigne la variable después de la inicialización, de modo que su valor permanecerá constante durante la duración del bloque. 

  La COLLATE opción especifica una intercalación para usar para la variable. Si NOT NULL se especifica, una asignación de un valor nulo da como resultado un error de tiempo de ejecución. Todas las variables declaradas como NOT NULL deben tener un valor predeterminado no nulo especificado. Equal (=) se puede usar en lugar de PL / SQL :=.

  EJEMPLOS:

  quantity integer DEFAULT 32;
  url varchar := 'http://mysite.com';
  user_id CONSTANT integer := 10;

DECLARACIÓN DE PARÁMETROS DE FUNCIONES

ALIAS
  
  POR PARAMETROS

  CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
  BEGIN
      RETURN subtotal * 0.06;
  END;
  $$ LANGUAGE plpgsql;

  POR DECLARACION EXPLICITA

  name ALIAS FOR $n;

  EJEMPLOS

  CREATE FUNCTION sales_tax(real) RETURNS real AS $$
  DECLARE
      subtotal ALIAS FOR $1;
  BEGIN
      RETURN subtotal * 0.06;
  END;
  $$ LANGUAGE plpgsql;

  CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
  DECLARE
      v_string ALIAS FOR $1;
      index ALIAS FOR $2;
  BEGIN
      -- some computations using v_string and index here
  END;
  $$ LANGUAGE plpgsql;


  CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
  BEGIN
      RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
  END;
  $$ LANGUAGE plpgsql;

PARAMETROS DE SALIDA 

  CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
  BEGIN
      tax := subtotal * 0.06;
  END;
  $$ LANGUAGE plpgsql;

  los parámetros de salida son más útiles al devolver múltiples valores. Un ejemplo trivial es:

  CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
  BEGIN
      sum := x + y;
      prod := x * y;
  END;
  $$ LANGUAGE plpgsql;

  Otra forma de declarar una función PL / pgSQL es con RETURNS TABLE, por ejemplo:

  CREATE FUNCTION extended_sales(p_itemno int)
  RETURNS TABLE(quantity int, total numeric) AS $$
  BEGIN
      RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                   WHERE s.itemno = p_itemno;
  END;
  $$ LANGUAGE plpgsql;






  











</pre>